#ifndef ROTATEBST_H
#define ROTATEBST_H

#include "bst.h"
#include "unordered_set"

template <typename Key, typename Value>
class rotateBST<Key, Value> : public BinarySearchTree<Key, Value> {
public:
  bool sameKeys(const rotateBST &t2) const;
  void transform(rotateBST &t2) const;

protected:
  void leftRotate(Node<Key, Value> *r);
  void rightRotate(Node<Key, Value> *r);

private:
};

template <typename Key, typename Value>
void insertToHash(Node<Key, Value> *root, std::unordered_set<Key> &s) {
  if (!root) {
    return;
  }
  insertToHash(root->getLeft(), s);
  s.insert(root->getKey());
  insertToHash(root->getRight(), s);
}

template <typename Key, typename Value>
bool rotateBST<Key, Value>::sameKeys(const rotateBST<Key, Value> &t2) {
  // TODO
  if (!this->mRoot && !t2.mRoot) {
    return true;
  }
  if ((this->mRoot && !t2.mRoot) || (!this->mRoot && t2.mRoot)) {
    return false;
  }
  std::unordered_set<Key> tree1, tree2;
  insertToHash(this->mRoot, tree1);
  insertToHash(t2.mRoot, tree2);
  return (tree1 == tree2);
}

template <typename Key, typename Value>
void rotateBST<Key, Value>::transform(rotateBST<Key, Value> &t2) {
  // TODO
  if (!sameKeys(t2)) {
    return;
  }
}

template <typename Key, typename Value>
void rotateBST<Key, Value>::leftRotate(Node<Key, Value> *r) {
  // TODO
}

template <typename Key, typename Value>
void rotateBST<Key, Value>::rightRotate(Node<Key, Value> *r) {
  // TODO
}
#endif
